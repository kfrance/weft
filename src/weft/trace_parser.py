"""Trace parser for Claude Code conversation traces.

This module provides functions to parse the markdown-formatted conversation traces
generated by trace_capture.py. It isolates all Claude Code trace format dependencies
to a single module, making future format changes easier to handle.

WARNING: This module depends on the trace format generated by trace_capture.py.
If Claude Code's internal format changes, trace_capture.py may need updates,
but this module should only need updates if trace_capture.py's output format changes.
"""

from __future__ import annotations

import json
import re
from dataclasses import dataclass
from typing import Optional

from .logging_config import get_logger

logger = get_logger(__name__)


@dataclass
class ToolCall:
    """Represents a single tool call in the trace."""
    name: str
    parameters: dict
    timestamp: Optional[str] = None


@dataclass
class ToolResult:
    """Represents a tool result in the trace."""
    tool_use_id: str
    content: str  # Already truncated by trace_capture.py


@dataclass
class TraceMetadata:
    """Metadata extracted from the trace header."""
    session_id: str
    command: str
    timestamp: str
    worktree: str
    git_branch: str


class TraceParseError(Exception):
    """Raised when trace parsing fails."""
    pass


def parse_trace_metadata(content: str) -> TraceMetadata:
    """Extract session metadata from the trace header.

    Args:
        content: Full trace markdown content

    Returns:
        TraceMetadata with extracted fields

    Raises:
        TraceParseError: If required metadata fields are missing
    """
    metadata = {}

    # Extract Session ID
    session_match = re.search(r'\*\*Session ID\*\*:\s*(.+)', content)
    if session_match:
        metadata['session_id'] = session_match.group(1).strip()
    else:
        metadata['session_id'] = 'unknown'

    # Extract Command
    command_match = re.search(r'\*\*Command\*\*:\s*(.+)', content)
    if command_match:
        metadata['command'] = command_match.group(1).strip()
    else:
        metadata['command'] = 'unknown'

    # Extract Timestamp
    timestamp_match = re.search(r'\*\*Timestamp\*\*:\s*(.+)', content)
    if timestamp_match:
        metadata['timestamp'] = timestamp_match.group(1).strip()
    else:
        metadata['timestamp'] = 'unknown'

    # Extract Worktree
    worktree_match = re.search(r'\*\*Worktree\*\*:\s*(.+)', content)
    if worktree_match:
        metadata['worktree'] = worktree_match.group(1).strip()
    else:
        metadata['worktree'] = 'unknown'

    # Extract Git Branch
    branch_match = re.search(r'\*\*Git Branch\*\*:\s*(.+)', content)
    if branch_match:
        metadata['git_branch'] = branch_match.group(1).strip()
    else:
        metadata['git_branch'] = 'unknown'

    return TraceMetadata(**metadata)


def parse_tool_calls(content: str) -> list[ToolCall]:
    """Extract tool calls from the trace.

    Parses assistant messages looking for tool_use blocks in the format:
    **Tool: <name>**
    ```json
    { ... parameters ... }
    ```

    Args:
        content: Full trace markdown content

    Returns:
        List of ToolCall objects
    """
    tool_calls = []

    # Pattern to match tool calls: **Tool: Name** followed by json block
    # The timestamp is on the preceding ### line
    pattern = r'### \[([^\]]+)\][^\n]*\n\n(?:.*?)\*\*Tool: (\w+)\*\*\n```json\n(.*?)\n```'
    matches = re.findall(pattern, content, re.DOTALL)

    for timestamp, tool_name, params_json in matches:
        try:
            parameters = json.loads(params_json)
        except (json.JSONDecodeError, ValueError):
            parameters = {}

        tool_calls.append(ToolCall(
            name=tool_name,
            parameters=parameters,
            timestamp=timestamp,
        ))

    # Also match tool calls without preceding timestamp context
    simple_pattern = r'\*\*Tool: (\w+)\*\*\n```json\n(.*?)\n```'
    simple_matches = re.findall(simple_pattern, content, re.DOTALL)

    # Only add if we haven't already captured it
    for tool_name, params_json in simple_matches:
        try:
            parameters = json.loads(params_json)
        except (json.JSONDecodeError, ValueError):
            parameters = {}

        # Check if we already have this tool call (by comparing parameters)
        already_exists = any(
            tc.name == tool_name and tc.parameters == parameters
            for tc in tool_calls
        )
        if not already_exists:
            tool_calls.append(ToolCall(
                name=tool_name,
                parameters=parameters,
                timestamp=None,
            ))

    logger.debug("Parsed %d tool call(s)", len(tool_calls))
    return tool_calls


def parse_tool_results(content: str) -> list[ToolResult]:
    """Extract tool results from the trace.

    Parses user messages looking for tool_result blocks in the format:
    **Tool Result** (ID: <tool_use_id>)
    ```
    <content>
    ```

    Note: Tool results are already truncated by trace_capture.py.

    Args:
        content: Full trace markdown content

    Returns:
        List of ToolResult objects
    """
    tool_results = []

    # Pattern to match tool results
    pattern = r'\*\*Tool Result\*\* \(ID: ([^\)]+)\)\n```\n(.*?)\n```'
    matches = re.findall(pattern, content, re.DOTALL)

    for tool_use_id, result_content in matches:
        tool_results.append(ToolResult(
            tool_use_id=tool_use_id,
            content=result_content,
        ))

    logger.debug("Parsed %d tool result(s)", len(tool_results))
    return tool_results


def parse_subagent_sections(content: str) -> dict[str, str]:
    """Extract subagent conversation sections from the trace.

    Each subagent section starts with:
    ## Subagent: agent-<id>

    Args:
        content: Full trace markdown content

    Returns:
        Dictionary mapping agent ID to section content
    """
    subagent_sections = {}

    # Split on subagent headers
    # Pattern: ## Subagent: agent-<id>
    pattern = r'## Subagent: agent-([a-f0-9]+)\n'
    parts = re.split(pattern, content)

    # parts will be: [main_content, agent_id_1, section_1, agent_id_2, section_2, ...]
    if len(parts) > 1:
        # Process pairs of (agent_id, section_content)
        for i in range(1, len(parts), 2):
            if i + 1 < len(parts):
                agent_id = parts[i]
                section_content = parts[i + 1]
                # Extract just the section until the next ## header
                next_section = re.split(r'\n## ', section_content, maxsplit=1)
                subagent_sections[agent_id] = next_section[0].strip()

    logger.debug("Parsed %d subagent section(s)", len(subagent_sections))
    return subagent_sections


def detect_errors(content: str) -> list[str]:
    """Find error messages, test failures, and retries in the trace.

    Looks for:
    - Python tracebacks
    - "Error:" or "ERROR" messages
    - pytest failure summaries
    - Tool errors

    Args:
        content: Full trace markdown content

    Returns:
        List of error message strings
    """
    errors = []

    # Python tracebacks
    traceback_pattern = r'Traceback \(most recent call last\):.*?(?=\n\n|\n###|\Z)'
    traceback_matches = re.findall(traceback_pattern, content, re.DOTALL)
    errors.extend(traceback_matches[:5])  # Limit to first 5

    # Error messages
    error_pattern = r'(?:Error|ERROR|Failed|FAILED):\s*.{10,200}'
    error_matches = re.findall(error_pattern, content)
    errors.extend(error_matches[:10])  # Limit to first 10

    # pytest failures
    pytest_pattern = r'FAILED\s+\S+::\S+.*?(?=\n(?:FAILED|PASSED|=====|\Z))'
    pytest_matches = re.findall(pytest_pattern, content, re.DOTALL)
    errors.extend(pytest_matches[:5])  # Limit to first 5

    # Tool errors (from tool results)
    tool_error_pattern = r'tool_use_error[^\n]*\n(.*?)(?=\n\n|\n```|\Z)'
    tool_error_matches = re.findall(tool_error_pattern, content, re.DOTALL)
    errors.extend(tool_error_matches[:5])  # Limit to first 5

    # Deduplicate while preserving order
    seen = set()
    unique_errors = []
    for error in errors:
        error_normalized = error.strip()[:200]  # Use first 200 chars for dedup
        if error_normalized not in seen:
            seen.add(error_normalized)
            unique_errors.append(error.strip())

    logger.debug("Detected %d unique error(s)", len(unique_errors))
    return unique_errors


def count_tools_by_type(tool_calls: list[ToolCall]) -> dict[str, int]:
    """Count tool calls by tool name.

    Args:
        tool_calls: List of ToolCall objects

    Returns:
        Dictionary mapping tool name to count
    """
    counts: dict[str, int] = {}
    for tc in tool_calls:
        counts[tc.name] = counts.get(tc.name, 0) + 1
    return counts


def extract_file_paths(tool_calls: list[ToolCall]) -> dict[str, set[str]]:
    """Extract file paths from tool calls.

    Groups files by operation type:
    - read: Files accessed via Read tool
    - modified: Files modified via Edit tool
    - created: Files created via Write tool

    Args:
        tool_calls: List of ToolCall objects

    Returns:
        Dictionary with 'read', 'modified', 'created' keys, each containing set of paths
    """
    file_paths: dict[str, set[str]] = {
        'read': set(),
        'modified': set(),
        'created': set(),
    }

    for tc in tool_calls:
        if tc.name == 'Read':
            path = tc.parameters.get('file_path', '')
            if path:
                file_paths['read'].add(path)
        elif tc.name == 'Edit':
            path = tc.parameters.get('file_path', '')
            if path:
                file_paths['modified'].add(path)
        elif tc.name == 'Write':
            path = tc.parameters.get('file_path', '')
            if path:
                file_paths['created'].add(path)

    return file_paths


def extract_bash_commands(tool_calls: list[ToolCall]) -> list[str]:
    """Extract bash command strings from Bash tool calls.

    Args:
        tool_calls: List of ToolCall objects

    Returns:
        List of command strings (without output)
    """
    commands = []
    for tc in tool_calls:
        if tc.name == 'Bash':
            command = tc.parameters.get('command', '')
            if command:
                commands.append(command)
    return commands
