---
plan_id: finalize-command
status: done
evaluation_notes: []
git_sha: a6842a173fb96006e68edcd0b981eeaeed246839
---

## Objectives

Implement a `lw_coder finalize` command that automates the workflow of finalizing work from a plan's worktree by committing changes, merging them into the main branch, and cleaning up. The command should follow the same AI-agent-driven pattern as the existing `plan` and `code` commands, launching Claude Code CLI or Droid to perform all operations interactively.

## Requirements & Constraints

### Functional Requirements

- **Command signature**: `lw_coder finalize <plan_path> [--tool <tool_name>] [--debug]`
  - Takes path to plan file (extracts plan_id from front matter)
  - Supports `--tool` parameter for executor selection (claude-code or droid)
  - Supports `--debug` flag for verbose logging

- **Pre-flight validation**:
  - Extract plan_id from plan file's YAML front matter
  - Locate corresponding worktree at `.lw_coder/worktrees/<plan_id>`
  - Fail if worktree has no uncommitted changes (nothing to finalize)
  - Update plan status to "done" if not already set
  - Copy plan file from main repo's `.lw_coder/tasks/<plan_id>.md` to worktree's `.lw_coder/tasks/<plan_id>.md`

- **Finalization workflow** (performed by AI agent via prompt template):
  1. Verify uncommitted changes exist in worktree
  2. Analyze all changed and untracked files
  3. Stage files that are clearly related to the plan implementation
  4. For files that appear unrelated, temporary (e.g., `.pyc`, `.log`, `__pycache__`, temp files), or testing artifacts, verify with user before staging
  5. Generate commit message following format:
     ```
     <short descriptive summary>
     @.lw_coder/tasks/<plan_id>.md

     <detailed description of changes>
     ```
  6. Commit all staged changes including the plan file
  7. Rebase the worktree branch onto main (AI resolves conflicts interactively if needed)
  8. Switch to main branch and fast-forward merge the worktree branch
  9. Remove worktree and delete branch

- **Commit message requirements**:
  - Line 1: Short description (auto-generated by AI based on git diff)
  - Line 2: `@.lw_coder/tasks/<plan_id>.md` reference
  - Line 3+: Detailed description (auto-generated)
  - Plan file must be included in the commit

- **Error handling**:
  - Fail early if no changes to commit
  - Fail early if staging/committing fails
  - No automatic rollback - AI agent helps user resolve failures interactively
  - User reviews/approves operations via Claude Code permission prompts

### Non-Functional Requirements

- **Consistency**: Follow same architectural patterns as `plan_command.py` and `code_command.py`
- **Template-driven**: Use prompt templates in `src/lw_coder/prompts/{claude-code,droid}/finalize.md`
- **Logging**: Comprehensive logging at info and debug levels
- **Testing**: Unit tests following `docs/BEST_PRACTICES.md` guidelines

### Constraints

- Must work with both Claude Code CLI and Droid executors
- Must preserve linear git history (rebase + fast-forward merge, no merge commits)
- Plan file is source of truth - always in main repo's `.lw_coder/tasks/`
- No optimized prompts needed (finalize is simpler than code command)

## Work Items

### 1. Create finalize command module
**File**: `src/lw_coder/finalize_command.py`

- Implement `run_finalize_command(plan_path: Path | str, tool: str = "claude-code") -> int`
- Load plan file and extract plan_id from front matter using existing validators
- Validate worktree exists at `.lw_coder/worktrees/<plan_id>`
- Check for uncommitted changes in worktree (fail if none exist)
- Update plan status to "done" if not already (using `plan_lifecycle.update_plan_fields`)
- Copy plan file from main repo's `.lw_coder/tasks/<plan_id>.md` to worktree's `.lw_coder/tasks/<plan_id>.md`
- Load prompt template for the specified tool
- Create temporary prompt file with plan context
- Set up executor (Claude Code CLI or Droid) similar to `plan_command.py`
- Execute AI agent in worktree context
- Return appropriate exit code

### 2. Create prompt templates
**Files**:
- `src/lw_coder/prompts/claude-code/finalize.md`
- `src/lw_coder/prompts/droid/finalize.md`

Template should instruct AI agent to:
- Verify uncommitted changes exist (fail if clean working directory)
- Analyze all changed and untracked files using `git status`
- Stage files clearly related to the plan implementation
- For files that appear unrelated, temporary (`.pyc`, `.log`, `__pycache__`, temp files), or testing artifacts, ask user for confirmation before staging
- Generate commit message by analyzing `git diff --staged`
- Format message: short description on line 1, then `@.lw_coder/tasks/<plan_id>.md` reference on line 2, detailed description after
- Commit: `git commit -m "<message>"`
- Rebase onto main: `git rebase main` (work through conflicts if needed)
- Switch to main: `git checkout main`
- Fast-forward merge: `git merge --ff-only <branch>`
- Remove worktree: `git worktree remove <path>`
- Delete branch: `git branch -d <branch>`

### 3. Integrate into CLI
**File**: `src/lw_coder/cli.py`

- Add finalize command to usage string:
  ```
  lw_coder finalize <plan_path> [--tool <tool_name>] [--debug]
  ```
- Add argument parsing for finalize command
- Import and call `run_finalize_command` with appropriate parameters
- Follow same pattern as existing plan and code commands

### 4. Add worktree validation helper
**File**: `src/lw_coder/worktree_utils.py` (add to existing file)

- Implement `get_worktree_for_plan(repo_root: Path, plan_id: str) -> Path | None`
  - Check if worktree exists at `.lw_coder/worktrees/<plan_id>`
  - Verify it's a registered git worktree
  - Return path if valid, None otherwise

### 5. Add uncommitted changes check helper
**File**: `src/lw_coder/worktree_utils.py` (add to existing file)

- Implement `has_uncommitted_changes(worktree_path: Path) -> bool`
  - Run `git status --porcelain` in worktree
  - Return True if output is non-empty, False otherwise

### 6. Add tests
**File**: `tests/test_finalize_command.py`

- Test plan file loading and plan_id extraction
- Test worktree existence validation
- Test uncommitted changes detection
- Test plan status update to "done"
- Test plan file copy from main repo to worktree
- Test error handling for missing worktree
- Test error handling for no uncommitted changes
- Test error handling for invalid plan file
- Test executor selection (claude-code vs droid)
- Follow `docs/BEST_PRACTICES.md` - use real components, no mocking of DSPy/LLMs

### 7. Update documentation
**File**: `CLAUDE.md`

- Add finalize command to CLI usage section:
  ```
  - **Finalize plan**: `uv run lw_coder finalize <plan_path>`
  ```

## Deliverables

1. `src/lw_coder/finalize_command.py` - Main command implementation
2. `src/lw_coder/prompts/claude-code/finalize.md` - Claude Code prompt template
3. `src/lw_coder/prompts/droid/finalize.md` - Droid prompt template
4. Updated `src/lw_coder/cli.py` - CLI integration
5. Updated `src/lw_coder/worktree_utils.py` - Worktree validation and change detection helpers
6. `tests/test_finalize_command.py` - Comprehensive test coverage
7. Updated `CLAUDE.md` - Documentation
8. All tests pass: `uv run pytest`

## Out of Scope

- Automatic rollback or recovery mechanisms (AI agent helps user through failures)
- Squash merge or other merge strategies (only rebase + fast-forward)
- Interactive editing of commit messages (AI generates, user reviews via Claude Code prompts)
- Optimized prompts (not needed for this simpler workflow)
- Support for plans without worktrees (must have existing worktree)
- Finalizing multiple plans at once (single plan per invocation)
- Custom commit message templates or formats
- Integration with external issue trackers or PR tools
- Updating plan file metadata with merged_sha (would require additional commit)

## Test Cases

```gherkin
Feature: Finalize Plan Workflow
  Scenario: Successfully finalize a completed plan
    Given a plan file at .lw_coder/tasks/my-feature.md with status "done"
    And a worktree exists at .lw_coder/worktrees/my-feature
    And the worktree has uncommitted changes
    When I run "lw_coder finalize .lw_coder/tasks/my-feature.md"
    Then the plan file is copied to the worktree's .lw_coder/tasks/ directory
    And the AI agent analyzes and stages relevant changes
    And the AI agent commits with plan reference "@.lw_coder/tasks/my-feature.md"
    And the AI agent rebases onto main
    And the AI agent merges into main with fast-forward
    And the worktree is removed
    And the branch is deleted

  Scenario: Update plan status before finalizing
    Given a plan file with status "coding"
    And a worktree with uncommitted changes
    When I run "lw_coder finalize <plan_path>"
    Then the plan status is updated to "done"
    And the finalize workflow proceeds normally

  Scenario: Fail when no changes to finalize
    Given a plan file with an existing worktree
    And the worktree has no uncommitted changes
    When I run "lw_coder finalize <plan_path>"
    Then the command fails with error "No changes to finalize"
    And no git operations are performed

  Scenario: Handle rebase conflicts interactively
    Given a plan file and worktree with changes
    And main branch has conflicting changes
    When I run "lw_coder finalize <plan_path>"
    And the rebase encounters conflicts
    Then the AI agent helps resolve conflicts interactively
    And the rebase completes successfully
    And the merge proceeds

  Scenario: Fail when worktree doesn't exist
    Given a plan file at .lw_coder/tasks/my-feature.md
    And no worktree exists for the plan
    When I run "lw_coder finalize .lw_coder/tasks/my-feature.md"
    Then the command fails with error "Worktree not found for plan my-feature"

  Scenario: Use Droid executor instead of Claude Code
    Given a plan file and worktree
    When I run "lw_coder finalize <plan_path> --tool droid"
    Then the finalize workflow executes using Droid
    And all operations complete successfully

  Scenario: Plan file is committed with code changes
    Given a worktree with code changes
    And the plan file has been copied to the worktree during pre-flight
    When the AI agent commits during finalize
    Then the commit includes both code changes and .lw_coder/tasks/<plan_id>.md
    And the commit message references the plan file

  Scenario: Verify staging of unrelated files
    Given a worktree with plan-related changes and temporary files
    When the AI agent analyzes files for staging
    Then plan-related files are staged automatically
    And the AI agent asks user confirmation before staging .pyc files
    And the AI agent asks user confirmation before staging .log files
    And the AI agent asks user confirmation before staging files in __pycache__
```
